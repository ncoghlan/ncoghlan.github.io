<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Efficiency (a virtue) is the child of laziness and greed (both vices), while
much of our economic activity is devoted to preventing boredom in the idle
time created by increases in efficiency. To be human is to be a strange
creature indeed :)
">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Curious Efficiency (old posts, page 3) | Curious Efficiency</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://www.curiousefficiency.org/index-3.html">
<link rel="prev" href="index-4.html" type="text/html">
<link rel="next" href="index-2.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://www.curiousefficiency.org/">

                <span id="blog-title">Curious Efficiency</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" role="navigation" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="pages/about.html">About</a>
                </li>
<li>
<a href="archive.html">Archives</a>
                </li>
<li>
<a href="categories/index.html">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS</a>
                </li>
<li>
<a href="https://python-notes.curiousefficiency.org">Python Notes</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/03/python-vm-summit-rough-notes.html" class="u-url">Python VM Summit - Rough Notes</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/03/python-vm-summit-rough-notes.html" rel="bookmark"><time class="published dt-published" datetime="2011-03-10T01:28:00Z" title="2011-03-10 01:28">2011-03-10 01:28</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/03/python-vm-summit-rough-notes.html#disqus_thread" data-disqus-identifier="cache/posts/2011/03/python-vm-summit-rough-notes.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>In parallel with the the 2 days of tutorials at Pycon, there are a couple of day long meetings for invited folks active in the evolution of the language itself. Today was the VM summit, which focuses on the major Python interpreter implementations (CPython, PyPy, Jython, IronPython), the current status of each, and where things are likely to head in the near- and long-term. (The Thursday session focuses more on the evolution of the language itself, as well as of the wider ecosystem).<br><br>CPython and PyPy both had multiple devs at the summit, IronPython and Jython devs were also there (although IronPython got to share their's with CPython). We also has some Parrot VM folks there, as well as one of the Mozilla Javascript devs - a bunch of issues with VM development for dynamic languages apply across languages, despite differences in the surface syntax.<br><br>The notes below are probably too cryptic to make sense out of context, bit will hopefully give the gist of what was discussed. These notes are my interpretation of what was said, and may or may not reflect what people actually meant. Names omitted to protect the guilty (and because I didn't write them down)<br><br>Commit rights for other VM core devs<br>  - good idea<br>  - did some of this last Pycon US<br>  - will look into adding more this week<br><br>Splitting out the standard library and test suite (again)<br>  - duplication of effort between CPython/IronPython/Jython/PyPy<br>  - shared commit rights intended to make it easier near term to use CPython as master, allowing bugs to be fixed "upstream"<br>  - hg transition should make sharing easier<br>  - main CPython release will stay "batteries included"<br>  - open to the idea of providng "CPython minimal" and "standard library" downloads (but much work to be done in defining a minimum set)<br>  - longer term, may want to separate pure-Python stdlib development from "C skills required" hacking on the CPython interpreter core and C accelerated implementation modules for the stdlib<br><br>Speed benchmarking<br>  - speed.pypy.org (very cool!)<br>  - benchmarks originally chosen by Unladen Swallow team<br>  - PSF may talk to OSU OSL about setting up speed.python.org<br>  - benchmark multiple versions of CPython, as well as Jython and IronPython<br>  - currently benchmarks are 2.x specific, may be a while before 3.x can be compared fully<br>  - may be GSoC projects in:<br>      - improving backend infrastructure to handle more interpreters<br>      - porting benchmarks to Python 3<br>  - can highlight key performance differences between the implementations (e.g slowspitfire vs spitfire-cstringio)<br><br>Python.org download pages<br>  - should start recommending alternative interpreters more prominently<br>  - PyPy likely to be faster for pure Python on major platforms<br>  - IronPython/Jython/CPython still best at integration with their respective environments (Java libraries, .NET linraries, C extensions)<br><br>Cool hacks<br>  - Maciel: pypy JIT viewer<br>  - Dave Malcolm: CPython HEAP viewer in GDB 7<br>  <br>Parrot VM (and JIT for dynamic languages)<br>  - target VM for dynamic languages (primarily Perl 6 and Tcl at the moment)<br>  - loadable operations, loadable object types  <br>  - dynamic ops were original speed target, now moving towards dynamic types instead<br>  - exploring reducing number of core ops to make JIT more practical<br>  - looking into taking advantage of LLVM<br>  - Unladen Swallow blazed this trail, so LLVM has better dynamic language support<br>  - PyPy has tried and failed to use LLVM as an effective backend<br>  - some issues may have been fixed due to Unladen Swallow's efforts, but others still exist (e.g. problems with tail recursion)<br>  - SpiderMonkey similarly struggles with JIT and dynamic patching issues<br>  - GNU Lightning and LiveJIT projects noted, but nobody really familiar with them  <br>  - any future Python-on-Parrot efforts likely to focus on using PyPy frontend with Parrot as a backend<br>  - proof-of-concept written (for a thesis?) that used .NET as a backend target for PyPy<br>  - original Python-on-Parrot ran into problems due to semantic mismatches between Perl 6 and Python - reached the limits of the degree of difference the Perl 6 toolchain was willing to tolerate)<br>  <br>Role of the PSF<br>  - supports Python the Language, not just CPython the Reference Interpreter<br>  - could use additional feedback on how to better fulfill that role<br>  - getting the "boring stuff" done?<br>  - project-based grants, not blanket personal funding<br>  - project proposals requiring more funds than the PSF can provide are still valuable, as PSF can help facilitate co-sponsorships (however, still a novel concept - only been done once so far).<br><br>2.7 to 3.2<br>  - PyPy just reaching feature parity with 2.7<br>  - PyPy now becoming far more interesting for production usage<br>  - treat PyPy Python 3 dialect like a major Python library (e.g. sponsored by PSF)<br><br>CPython warnings for reliance on implementation details<br>  - ResourceWarning was a nice addition (detects reliance on refcounting for resource cleanup<br>  - non-string keys in class namespaces would be another good candidate for a warning<br>  - clarifying finalisation-at-shutdown semantics would be nice (but fixing those semantics in CPython first would help with that)</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/03/what-is-python-script.html" class="u-url">What is a Python script?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/03/what-is-python-script.html" rel="bookmark"><time class="published dt-published" datetime="2011-03-06T14:19:00Z" title="2011-03-06 14:19">2011-03-06 14:19</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/03/what-is-python-script.html#disqus_thread" data-disqus-identifier="cache/posts/2011/03/what-is-python-script.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>This is an adaptation of a <a href="http://pyvideo.org/video/471/pyconau-2010--lightning-talks---saturday">lightning talk</a> I gave at PyconAU 2010, after realising a lot of the people there had no idea about the way CPython's concept of what could be executed had expanded over the years since version 2.4 was released. As of Python 2.7, there are actually 4 things that the reference interpreter will accept as a main module.<br><br><b>Ordinary scripts:</b> the classic main module identified by filesystem path, available for as long as Python has been around. Can be executed without naming the interpreter through the use of file associations (Windows) or shebang lines (pretty much everywhere else).<br><br><b>Module name:</b> By using the <span>-m</span> switch, a user can tell the interpreter to locate the main module based on its position in the module hierarchy rather than by its location on the filesystem. This has been supported for top level modules since Python 2.4, and for all modules since Python 2.5 (via PEP 338). Correctly handles explicit relative imports since Python 2.6 (via PEP 366 and the <span>__package__</span> attribute). The classic example of this usage is the practice of invoking <span>"python -m timeit 'snippet'"</span> when discussing the relative performance of various Python expressions and statements.<br><br><b>Valid sys.path entry:</b> If a valid sys.path entry (e.g. the name of a directory or a zipfile) is passed as the script argument, CPython will automatically insert that location at the beginning of <span>sys.path</span>, then use the module name execution mechanism to look for a <span>__main__</span> module with the updated <span>sys.path</span>. Supported since Python 2.6, this system allows quick and easy bundling of a script with its dependencies for internal distribution within a company or organisation (external distribution should still use proper packaging and installer development practices). When using zipfiles, you can even add a shebang line to the zip header or use a file association for a custom extension like <span>.pyz</span> and the interpreter will still process the file correctly.<br><br><b>Package name: </b>If a package name is passed as the value for the <span>-m</span> switch, the Python interpreter will reinterpret the command as referring to a <span>__main__</span> submodule within that package. This version of the feature was added in Python 2.7, after some users objected to the removal in Python 2.6 of the original (broken) code that incorrectly allowed a package's <span>__init__.py</span> to be executed as the main module. Starting in Python 3.2, CPython's own test suite supports this feature, allowing it to be executed as <span>"python -m test"</span>.<br><br>The above functionality is exposed via the <span>runpy</span> module, as <span>runpy.run_module() </span>and <span>runpy.run_path()</span>.<br><br>If anyone ever sees me (metaphorically) jumping up and down about making sure things get mentioned in the What's New document for a new Python version, this is why. Python 2.6 was released in October 2008, but we didn't get the note about the zipfile and directory execution trick into the What's New until February 2010. It is described in the documentation, but really, who reads the command line documentation, or is likely to be casually browsing the <span>runpy</span> docs? This post turning up on Planet Python will probably do more to get the word out about the functionality than anything we've done before now :)</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/status-quo-wins-stalemate.html" class="u-url">Status quo wins a stalemate</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/status-quo-wins-stalemate.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T15:07:00Z" title="2011-02-27 15:07">2011-02-27 15:07</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/status-quo-wins-stalemate.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/status-quo-wins-stalemate.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>Sometimes language design arguments can reach a point of stalemate. The status quo is only arguably flawed, and there are also perceived flaws in any or all of the proposed alternatives. An appropriate shared design principle can help identify when this point has been reached, and let the discussion die a natural death rather than endlessly rehashing the same points without anyone changing their opinion.<br><br>Every time we (python-dev) change anything significant, no matter how positive the end result, it can create a lot of churn in the community. Books need to be rewritten, other implementations modified, advice, recipes and examples updated, questions clarified as to which version they relate to, and version compatibility issues need to be monitored closely for projects that need to cope with older execution environments.<br><br>So, before any significant changes are made, we want to be fairly certain that the gain in clarity for future Python programs is worth the inevitable near term costs as the update ripples across the Python ecosystem. Sometimes newcomers have some interesting ideas, but still fail to clear this hurdle. The simple "it's not worth the hassle" response they're likely to receive may then come across as stodgy developers rejecting an outsider's ideas without adequate consideration.<br><br>This was something that came up fairly often during the Python 3000 mailing list discussions, to the point where I posted a message explaining why the principle of <a href="http://mail.python.org/pipermail/python-3000/2006-May/001936.html">"Status quo wins a stalemate"</a> is a very practical way to avoid meaningless churn in the language design and to cut short design discussions that obviously aren't going anywhere productive.<br><br>Python 3000 was already going to have a lot of major changes (most notably, finally improving the non-ASCII text handling story, in a way that means most Python 3 libraries and applications will be more likely to get it right). We needed to ride close herd on the design discussions to try to make sure that gratuitous changes with insufficient long term benefits were avoided.<br><br>So, lambda eventually stayed and map() and filter() were retained as builtins, while the attractive nuisance that is reduce() was merely banished to the functools module rather than getting dropped entirely as was originally proposed. PEP 348 was rejected to be replaced by the far less ambitious PEP 352. str.format() was still added, but as a complement to the legacy percent formatting mechanism rather than as a wholesale replacement.<br><br>Untold numbers of ideas on the mailing lists and the tracker were dropped with "too much pain for not enough benefit" as the rationale. More recently, PEP 3003 was instituted to enforce a moratorium on core language changes for Python 3.2 in order to give the rest of the community more time to catch up to Python 2.7 and the 3.x series, even though we knew it meant delaying good ideas like the improved generator refactoring capabilities provided by PEP 380.<br><br>The fact that Python 3 migration support tools like 2to3, 3to2 and the six module work as well as they do is probably due to this principle of language design as much as it is to any other factor (not to take anything away from the fine work that has gone into implementing them, of course!).</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/posting-code-and-syntax-highlighting.html" class="u-url">Posting code and syntax highlighting</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/posting-code-and-syntax-highlighting.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T09:43:00Z" title="2011-02-27 09:43">2011-02-27 09:43</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/posting-code-and-syntax-highlighting.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/posting-code-and-syntax-highlighting.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>Before publishing the previous post, I looked into recommendations for syntax highlighting in coding-oriented blogs. In a quick search, syntaxhighlighter showed up repeatedly as the preferred choice, so that's what I went with.<br><br>It looks like I'm not the only one <a href="http://www.knowthytools.com/2010/03/blogging-with-restructuredtext-and.html">that isn't entirely happy with that solution</a> (although by using the "pre" tags rather than "script", my code should at least appear in the RSS feed).<br><br>Working with ReST would certainly be easier than the semi-HTML I'm currently using. Still, I think I have plenty to learn about Blogger's formatting tools before I abandon them entirely in favour of preformatted posts (which have their own drawbacks).</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/justifying-python-language-changes.html" class="u-url">Justifying Python language changes</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/justifying-python-language-changes.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T09:13:00Z" title="2011-02-27 09:13">2011-02-27 09:13</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/justifying-python-language-changes.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/justifying-python-language-changes.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>A few years back, I <a href="http://mail.python.org/pipermail/python-dev/2008-October/082831.html">chipped in on python-dev</a> with a review of syntax change proposals that had made it into the language over the years. With Python 3.3 development starting and the language moratorium being lifted, I thought it would be a good time to tidy that up and republish it as a blog post.<br><br>Generally speaking, syntactic sugar (or new builtins) need to take a construct in idiomatic Python that is fairly obvious to an experienced Python user and make it obvious to even new users, or else take an idiom that is easy to get wrong when writing (or miss when reading) and make it trivial to use correctly.<br><br>Providing significant performance improvements (usually in the form of reduced memory usage or increased speed) also counts heavily in favour of new constructs.<br><br>I strongly suggest browsing through past PEPs (both accepted and rejected ones) before proposing syntax changes, but here are some examples of syntactic sugar proposals that were accepted.<br><br><b>List/set/dict comprehensions</b><br>(and the reduction builtins any(), all(), min(), max(), sum())<br></p>
<pre class="brush: py">target = [op(x) for x in source]</pre>instead of:<br><pre class="brush: py">target = []<br>for x in source:<br>    target.append(op(x))</pre>The transformation (`op(x)`) is far more prominent in the comprehension version, as is the fact that all the loop does is produce a new list. I include the various reduction builtins here, since they serve exactly the same purpose of taking an idiomatic looping construct and turning it into a single expression.<br><br><b>Generator expressions</b><br><pre class="brush: py">total = sum(x*x for x in source)</pre>instead of:<br><pre class="brush: py">def _g(source):<br>    for x in source:<br>        yield x*x<br>total = sum(_g(x))</pre>or:<br><pre class="brush: py">total = sum([x*x for x in source])</pre>Here, the GE version has obvious readability gains over the generator function version (as with comprehensions, it brings the operation being applied to each element front and centre instead of burying it in the middle of the code, as well as allowing reduction operations like sum() to retain their prominence), but doesn't actually improve readability significantly over the second LC-based version. The gain over the latter, of course, is that the GE based version needs a lot <i>less memory</i> than the LC version, and, as it consumes the source data<br>incrementally, can work on source iterators of arbitrary (even infinite) length, and can also cope with source iterators with large time gaps between items (e.g. reading from a socket) as each item will be returned as it becomes available (obviously, the latter two features aren't useful when used in conjunction with reduction operations like sum, but they can be helpful in other contexts).<br><br><b>With statements</b><br><pre class="brush: py">with lock:<br>    # perform synchronised operations</pre>instead of:<br><pre class="brush: py">lock.acquire()<br>try:<br>    # perform synchronised operations<br>finally:<br>    lock.release()</pre>This change was a gain for both readability and writability - there were plenty of ways to get this kind of code wrong (e.g. leave out the try-finally altogether, acquire the resource inside the try block instead of before it, call the wrong method or spell the variable name wrong when attempting to release the resource in the finally block), and it wasn't easy to audit because the resource acquisition and release could be separated by an arbitrary number of lines of code. By combining all of that into a single line of code at the beginning of the block, the with statement eliminated a lot of those issues, making the code much easier to write correctly in the first place, and also easier to audit for correctness later (just make sure the code is using the correct context manager for the task at hand).<br><br><b>Function decorators</b><br><pre class="brush: py">@classmethod<br>def f(cls):<br>    # Method body</pre>instead of:<br><pre class="brush: py">def f(cls):<br>    # Method body<br>f = classmethod(f)</pre>Easier to write (function name only written once instead of three times), and easier to read (decorator names up top with the function signature instead of buried after the function body). Some folks still dislike the use of the @ symbol, but compared to the drawbacks of the old approach, the dedicated function decorator syntax is a huge improvement.<br><br><b>Conditional expressions</b><br><pre class="brush: py">x = A if C else B</pre>instead of:<br><pre class="brush: py">x = C and A or B</pre>The addition of conditional expressions arguably wasn't a particularly big win for readability, but it <i>was</i> a big win for correctness. The and/or based workaround for the lack of a true conditional expression was not only hard to read if you weren't already familiar with the construct, but using it was also a potential source of bugs if A could ever be False while C was True (in such cases, B would be returned from the expression instead of A).<br><br><b>Except clause</b><br><pre class="brush: py">except Exception as ex:</pre>instead of:<br><pre class="brush: py">except Exception, ex:</pre>Another example of changing the syntax to reduce the potential for non-obvious bugs (in this case, except clauses like `except TypeError, AttributeError:`, that would actually never catch AttributeError, and would locally do AttributeError=TypeError if a TypeError was caught).
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/bye-bye-blogilo.html" class="u-url">Bye-bye Blogilo</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/bye-bye-blogilo.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-15T13:29:00Z" title="2011-02-15 13:29">2011-02-15 13:29</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/bye-bye-blogilo.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/bye-bye-blogilo.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>OK, when a blogging app can't figure out my blog identity automatically and crashes every time I submit a post (but after submitting the post to blogger), 'tis clearly not the app for me.<br><br>I'm just happy the first 3 posts didn't properly include the 'python' tag either, so at least Planet Python shouldn't have been spammed with any noise.<br><br>Back to the in-browser editor for now...</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/to-pycon-and-beyond_8775.html" class="u-url">To Pycon and beyond...</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/to-pycon-and-beyond_8775.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-15T13:21:00Z" title="2011-02-15 13:21">2011-02-15 13:21</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/to-pycon-and-beyond_8775.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/to-pycon-and-beyond_8775.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>All these Planet Python posts about interesting talks and info at Pycon finally tipped me over the edge into making the trek across the Pacific to meet some of these people I've been working with online for the past half-dozen years or so.</p>
<p>With 3.3 still 18-24 months away, we should be able to get a pretty good road map thrashed out for ideas we want to explore for possible inclusion. Some face-to-face discussions will be especially handy for me, given the things I'd like to see sorted out: module aliasing to clean up __main__ handling once and for all, bringing back implicit context managers now we have more collective experience with explicit ones, an alternative to PEP 377 that will allow context managers to do some additional setup inside the scope of the try block, clarifying the semantic questions raised by discrepancies between the PEP 3118 buffer API spec and its implementation.</p>
<p>I still have some paperwork to sort out once my renewed passport arrives, but aside from that, the trip is good to go. I did stuff my travel dates up a bit and will have a day to kill in Atlanta on the 9th, but I'm sure I'll be able to figure out something interesting to do :)</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/02/linking-sites-in-blog-posts.html" class="u-url">Linking sites in blog posts</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/02/linking-sites-in-blog-posts.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-04T14:30:00Z" title="2011-02-04 14:30">2011-02-04 14:30</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/02/linking-sites-in-blog-posts.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/linking-sites-in-blog-posts.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Call me paranoid, but the idea of trusting a blogging app with my Google account details really doesn't appeal to me. So, "BlogThis!" on the links bar it is.<br><br>It would be nice if BlogThis! popped up the full Blogger editor instead of a partial one (missing features like editing the post tags), but using it to save pre-linked drafts should be more than adequate for those occasions when I'm commenting on a link rather than writing something from scratch.</p>
<p>Test: editing an existing post...</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/01/comments-update-and-site-to-do-list.html" class="u-url">Comments update and site to-do list</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/01/comments-update-and-site-to-do-list.html" rel="bookmark"><time class="published dt-published" datetime="2011-01-27T12:50:00Z" title="2011-01-27 12:50">2011-01-27 12:50</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/01/comments-update-and-site-to-do-list.html#disqus_thread" data-disqus-identifier="cache/posts/2011/01/comments-update-and-site-to-do-list.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>Having used DISQUS elsewhere as a commenter and not being a great fan of the default Blogger comment system, I've configured the blog to use DISQUS instead.<br><br>I've also asked to have the blog's python related posts added to the Planet Python feed, so we'll see how that pans out.<br><br>The main thing I'm still not entirely happy with is the site colour scheme - while I'm still a fan of the whole light-text-on-dark-background style, the contrast between clicked links and the current black background really isn't significant enough. I'll probably tinker with that a bit over the next few days.</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/2011/01/some-goals-for-python-33.html" class="u-url">Some goals for Python 3.3</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posts/2011/01/some-goals-for-python-33.html" rel="bookmark"><time class="published dt-published" datetime="2011-01-27T12:45:00Z" title="2011-01-27 12:45">2011-01-27 12:45</time></a></p>
                <p class="commentline">
        
    <a href="posts/2011/01/some-goals-for-python-33.html#disqus_thread" data-disqus-identifier="cache/posts/2011/01/some-goals-for-python-33.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>With 3.2 nearly out the door, it's time to think seriously about goals for Python 3.3 and anything else I'd like to get done on the Python front this year. This post will serve as a to-do list of sorts.<br><br><b>PEP 1 Update</b><br>When cleaning up PEP 0 to clear out some of the accumulated cruft in the lists of Meta and Informational PEPs, I ran into a problem where the API specification PEPs use the "Final" state to indicate when consensus has been reached and the API has been locked in. This conflicts with the normal use of the Final state to indicate that a PEP is over a done with and is only being kept around for historical reasons.<br><br>A brief discussion on python-dev suggested "Consensus" as a new end state for these PEPs. I like that solution, but adopting it requires an update to PEP 1. I'd like to get to that sometime this year.<br><br><b>PEP 343 and 377, redux</b><br>There are a couple of rough edges on the with statement and the associated context management protocol that still bother me.<br><br>Firstly, the fact that there is no way for a context manager to skip the body of a with statement means certain constructs simply can't be factored out properly. I previously tried to address this with PEP 377, but that solution was rightly rejected as having too great an impact on common cases which didn't need the extra complexity. I have since thought of an alternative approach that is both more flexible and has a much lower impact on ordinary cases, so it has a higher chance of acceptance.<br><br>Secondly, I'd like to revisit the idea of implicit context managers. These were dropped from PEP 343 due largely to terminology problems - we weren't sure whether the term "context manager" referred to objects with enter and exit methods, or to the objects that were able to create such an object on demand. With the meaning of context manager now well established, I believe it should be possible to implement and document this in a way that makes intuitive sense, while making it significantly easier to write context managers that are both stateful and reusable.<br><br><b>That's my __name__, don't wear it out</b><br>As per a <a href="http://mail.python.org/pipermail/python-ideas/2011-January/008983.html">recent python-ideas discussion</a>, __name__ currently serves multiple masters, which leads to conflicts in certain situations (with __name__ set to a value that is correct for some purposes, but wrong for others). This is especially prevalent with the __main__ module, but can also apply to pseudo-packages, where something is documented as a single unified namespace, but is actually implemented as multiple files combined into a package.<br><br>For Python 3.3, I'd like to have a mechanism in place to start sorting this out without breaking every Python script on the planet that relies on the "if __name__ == '__main__':" idiom.<br><br><b>Other PEPs (e.g. PEP 380, 393)</b><br>There are a few other PEPs that will hopefully be landing for 3.3, including the subgenerator and memory efficient string PEPs. While I probably won't take much of an active hand in implementing those, there will still be plenty of related python-dev discussion and checkins to review.<br><br>And on a completely non-code-related front... with any luck I'll be able to find myself a more directly open source focused job this year. I have the luxury of being fussy in my choice of employment though, so I can happily sit back and relax while waiting to see how that pans out :)</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-4.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="boredomandlaziness";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2019 <a href="mailto:ncoghlan@gmail.com">Nick Coghlan</a> - <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, republish as you wish. - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a>
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
