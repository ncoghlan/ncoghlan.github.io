<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Curious Efficiency (Posts about pulpdist)</title><link>https://www.curiousefficiency.org</link><description></description><atom:link rel="self" href="https://www.curiousefficiency.org/categories/pulpdist.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 17 Mar 2019 04:34:15 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Spinning up the pulpdist project</title><link>https://www.curiousefficiency.org/posts/2011/09/spinning-up-pulpdist-project.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;p&gt;One novel aspect of the &lt;a href="https://www.curiousefficiency.org/2011/09/mirror-all-things.html"&gt;pulpdist project&lt;/a&gt; is that it is starting with an almost completely blank slate from a technology point of view (aside from the decision to use Pulp as the main component of the mirroring network). Red Hat does have development standards for internal projects, of course (especially in the messaging space), but they're fairly flexible, leaving the individual tool development teams with a lot of options. If something ships with Fedora and/or RHEL, or is available under licensing terms that would be acceptable for inclusion in Fedora (and subsequently RHEL), then it's fair game.&lt;br&gt;&lt;br&gt;This post focuses on the design of the management server. I'll write up a separate post looking at the currently planned design for the Pulp data transfer plugins. &lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Source Control&lt;/h2&gt;Unsurprisingly, Red Hat's internal processes are heavily influenced by Linux kernel processes. Accordingly, the source control tool of choice for new projects is Git. While I have a slight preference for Mercurial (due mainly to familiarity), I'm happy enough with any DVCS, so Git it is.&lt;br&gt;&lt;br&gt;&lt;h2&gt;Primary Development Language&lt;/h2&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;, of course. You don't hire a CPython core developer to get them to work on a Ruby or Perl project (although the current system I'm replacing was written in Perl). As a web application, there will naturally be some Javascript and CSS involved as well.&lt;br&gt;&lt;br&gt;&lt;h2&gt;Web Framework&lt;/h2&gt;The main management application for pulpdist is going to be a full-scale web application. User profiles and authentication, database storage, communication with other web services, provision of a REST API, integration with the engineering tools messaging bus. Basically, micro-frameworks need not apply.&lt;br&gt;&lt;br&gt;While I expect Pyramid/Pylons would also have been able to do the job, I decided to go with Django 1.3. This was heavily influenced by social factors: I know a lot of Django devs that I can bug for advice, but the same is not true for Pyramid. The complexity of the whole Pyramid/Pylons/TurboGears setup is also not appealing - while veteran web developers may find the "you decide" approach a selling point, Django's batteries included approach makes it far simpler to get started quickly, and decide as I go along which pieces I should keep, discard or replace.&lt;br&gt;&lt;br&gt;I've heard some experienced Django developers muttering complaints about the class based views design in 1.3, but as someone coming in that is an experienced Python developer, but a relatively noobish web developer, the CBV approach seems eminently sensible, while the old function based approach looks repetitive and insane. Object oriented programming was invented for a reason!&lt;br&gt;&lt;br&gt;I'll admit that my perception may be biased by knowing exactly how to make multiple inheritance work the way I want it to, though :)&lt;br&gt;&lt;br&gt;&lt;h2&gt;Web Server&lt;/h2&gt;The management server doesn't actually have that much work to do, so the basic Apache+mod_wsgi configuration will serve as an adequate starting point (any heavy lifting will be done by the individual Pulp instances, and the main data traffic on those doesn't run through their web service). WSGI provides the flexibility to revisit this later if needed.&lt;br&gt;&lt;br&gt;I've also punted on any web caching questions for now - the management server is low traffic and once the access to the Pulp sites is pushed out to a backend service, it should be fast enough at least for the early iterations. &lt;br&gt;&lt;br&gt;&lt;h2&gt;Authentication &amp;amp; Authorisation&lt;/h2&gt;The actual user authentication task will be handed off to Apache and all management application access will be restricted to Kerberos authenticated users over SSL. Django's own permissions systems will be used to handle authorisation restrictions. (The experimental prototype will use Basic Auth instead, since it is the Apache/Django integration the prototype needs to cover, not the Apache configuration for SSL and Kerberos authentication)&lt;br&gt;&lt;br&gt;Integration with Pulp's user access controls is via OAuth, but the design for configuration of user permissions in the Pulp servers is still TBD.&lt;br&gt;&lt;br&gt;&lt;h2&gt;Database and ORM&lt;/h2&gt;Again, the management server isn't doing the heavy lifting in this application. The Pulp instances use MongoDB, but for the management server I currently plan to use the standard Django ORM backed by PostgreSQL. For the prototype instance, the database is actually just an SQLite3 file. I'm not quite sold on this one as yet - it's tempting to start playing with SQLAlchemy, since I've already had to hack around some of the limitations in the native ORM in order to &lt;a href="http://djangosnippets.org/snippets/2489/"&gt;store encrypted fields&lt;/a&gt;. OTOH, I already have a ton of things to do on this project, so messing with this is a long way down the priority list.&lt;br&gt;&lt;br&gt;Schema and data maintenance is handled using &lt;a href="http://south.aeracode.org/"&gt;South&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;h2&gt;HTML Templating&lt;/h2&gt;The standard Django templating engine should be sufficient for my needs. As with the ORM, it's tempting to look into upgrading it to something like Jinja2, but once again 'good enough' is likely to be the deciding factor.&lt;br&gt;&lt;br&gt;For data table display, I'm using &lt;a href="http://pypi.python.org/pypi/django-tables2"&gt;Django Tables 2&lt;/a&gt; and form display will use &lt;a href="http://pypi.python.org/pypi/django-uni-form"&gt;Django Uni-Form&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;h2&gt;REST API&lt;/h2&gt;The REST API for the service is currently there primarily as a development aid - it lets me publish the full data model to the web as soon as it stabilises (and even while its still in flux), even if the UI for end users hasn't been fully defined. This is particularly useful for the metadata coming back from the Pulp server, since it doesn't need much post-processing to be included as raw data in the management server's own REST API. The JSON interface will also allow much of the backend processing to be fully exercised by the test suite without worrying about web UI details.&lt;br&gt;&lt;br&gt;The design of the REST API was heavily influenced by this &lt;a href="http://readthedocs.org/docs/restful-api-design/en/latest/"&gt;Lessons Learned&lt;/a&gt; piece from the RHEV-M developers. The &lt;a href="http://django-rest-framework.org/"&gt;Django Rest Framework&lt;/a&gt; means I can just define the data I want to display as a list or dictionary and the framework takes care of formatting it nicely, including rendering URLs as hyperlinks. &lt;br&gt;&lt;br&gt;&lt;h2&gt;AMQP Messaging&lt;/h2&gt;I haven't actually started on this aspect in any significant way, but the two main contenders I've identified are &lt;a href="http://www.silassewell.com/blog/tag/python-qpid/"&gt;python-qpid&lt;/a&gt; (which is what Pulp uses) and &lt;a href="http://ask.github.com/django-celery/"&gt;django-celery&lt;/a&gt; (which would also give me an internal task queue engine, which the management server is going to need - the prototype just does everything in the Django process, which is OK for experimentation on the LAN, but clearly inadequate long term when talking to multiple sites distributed around the planet). At this early stage, I expect the internal task management aspect is going to tip the decision in favour of the latter.&lt;br&gt;&lt;br&gt;&lt;h2&gt;Testing Regime&lt;br&gt;&lt;/h2&gt;As the foundation for the automated testing, I'm going with &lt;a href="http://devel.almad.net/docs/django-sane-testing/"&gt;Django Sane Testing&lt;/a&gt; (mainly based on the example of other internal Django projects). Michael Foord's &lt;a href="http://pypi.python.org/pypi/mock"&gt;mock module&lt;/a&gt; lets me run at least some of the tests without relying on an external Pulp instance (fortunately, the namespace conflict with Fedora's RPM building utility '&lt;a href="https://fedoraproject.org/wiki/Projects/Mock"&gt;mock&lt;/a&gt;' was recently resolved with the latter's support library being renamed to 'mockbuild').&lt;br&gt;&lt;br&gt;Continuous integration is an open question at this point. Pulp uses Jenkins for CI and I'm inclined to follow their lead. The other main possibility is to use &lt;a href="https://fedorahosted.org/beaker/"&gt;Beaker&lt;/a&gt;, Red Hat's internal test system originally set up for kernel testing (one key attraction Beaker offers is the ability to set up multi-server multi-site testing in a test recipe so I can run tests over the internal WAN).&lt;br&gt;&lt;br&gt;&lt;h2&gt;Packaging&lt;br&gt;&lt;/h2&gt;&lt;a href="https://github.com/dgoodwin/tito"&gt;Tito&lt;/a&gt; is a tool for generating SRPMs and RPMs directly from a Git repository. For my own packages, this is the approach I'm using (with handcrafted spec files). For some strange reason, the sysadmins around here like it when internal devs provide things as pre-packaged RPMs for deployment :)&lt;br&gt;&lt;br&gt;Packaging of upstream PyPI dependencies that aren't available as Fedora or RHEL packages is still a work in progress. I experimented with Tito and git submodules (which doesn't work) and git subtrees (which does work, but is seriously ugly). My next attempt is likely to be based on &lt;a href="http://pypi.python.org/pypi/py2pack"&gt;py2pack&lt;/a&gt;, so we'll see how that goes (I actually discovered that project by searching for 'cpanspec pypi' after hearing some of the Perl folks here extolling the virtues of cpanspec for easily packaging CPAN modules as RPMs).&lt;br&gt;&lt;br&gt;I also need to switch to using &lt;a href="http://pypi.python.org/pypi/virtualenv"&gt;virtualenv&lt;/a&gt; to get a clearer distinction between Fedora packages I added via yum install and stuff I picked up directly from PyPI with &lt;a href="http://pypi.python.org/pypi/pip"&gt;pip&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;br&gt;</description><category>pulpdist</category><category>python</category><guid>https://www.curiousefficiency.org/posts/2011/09/spinning-up-pulpdist-project.html</guid><pubDate>Tue, 27 Sep 2011 16:23:00 GMT</pubDate></item><item><title>Mirror All The Things!</title><link>https://www.curiousefficiency.org/posts/2011/09/mirror-all-things.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;p&gt;After describing the project I'm working on to a few people at PyConAU and BrisPy, I decided it might be a good idea to blog about it here. I do have a bit of an ulterior motive in doing so, though - I hope people will point out when I've missed useful external resources or applications, or when something I'm planning to do doesn't make sense to the assorted Django developers I know. Yes, that's right - I'd like to make being &lt;a href="https://www.xkcd.com/386/"&gt;wrong on the internet&lt;/a&gt; work in my favour :)&lt;br&gt;&lt;br&gt;The project is purely internal at this stage, but I hope to be able to publish it as open source somewhere down the line. Even being able to post these design concepts is pretty huge for me personally, though - before starting with Red Hat a few months ago, I spent the previous 12 and a half years working in the defence industry, which is about as far from Red Hat's &lt;a href="http://draft.blogger.com/goog_2071189574"&gt;"&lt;/a&gt;&lt;a href="http://draft.blogger.com/goog_2071189574"&gt;Default to Open" philosophy&lt;/a&gt; as it's possible to get.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;  Mirror, Mirror, On The Wall&lt;/h2&gt;The project Red Hat hired me to implement is the next generation of their internal mirroring system, which is used for various tasks, such as getting built versions of RHEL out to the hardware compatibility testing labs (and, when they're large enough, returning the generated log files to the relevant development sites), or providing internal Fedora mirrors at the larger Red Hat offices (such as the one here in Brisbane).&lt;br&gt;&lt;br&gt;There are various use cases and constraints that mean the mirroring system needs to operate at the filesystem level without making significant assumptions about the contents of the trees being mirrored (due to various details of the use cases involved, block level replication and approaches that rely on the transferred data being laid out in specific ways aren't viable alternatives for this project). The current incarnation of this system relies almost entirely on that venerable workhorse of the mirroring world, &lt;span&gt;rsync&lt;/span&gt;.&lt;br&gt;&lt;br&gt;However, the current system is also showing its age and has a few limitations that make it fairly awkward to work with. Notably, there's no one place to go to get an overview of the entire internal mirroring setup, and the direct use of &lt;span&gt;rsync&lt;/span&gt; means it isn't particularly friendly with other applications when it comes to sharing WAN bandwidth and the servers involved are wasting quite a few cycles recalculating the same deltas for multiple clients. Hence, the project I am working on, which is intended to replace the existing system with something a bit more efficient and easier to manage, while also providing a better platform for adding new features.&lt;br&gt;&lt;br&gt;&lt;h2&gt;  Enter Pulp&lt;/h2&gt;&lt;a href="http://pulpproject.org/"&gt;Pulp&lt;/a&gt; is an open source (Python) project created by Red Hat to make it easier to manage private &lt;span&gt;yum&lt;/span&gt; repositories. Via &lt;a href="http://katello.org/"&gt;Katello&lt;/a&gt;, Pulp is one of the upstream components for Red Hat's &lt;a href="https://www.redhat.com/solutions/cloud/cloudforms/"&gt;CloudForms&lt;/a&gt; product.&lt;br&gt;&lt;br&gt;The Pulp project is currently in the process of migrating from their original yum-specific architecture to a more general purpose &lt;a href="http://blog.pulpproject.org/2011/09/06/pulp-rearchitecture-sprint-update/"&gt;Generic Content plugin architecture&lt;/a&gt;. It's that planned plugin architecture that makes Pulp a useful basis for the next generation internal mirroring system, which, at least for now, I am imaginatively calling &lt;span&gt;pulpdist&lt;/span&gt; (referring to both "distribution with Pulp", since that's what the system does, and "distributed Pulp instances", since that's how the system will work).&lt;br&gt;&lt;br&gt;The main components of the initial &lt;span&gt;pulpdist&lt;/span&gt; architecture will be:&lt;br&gt;&lt;ul&gt;&lt;li&gt;a front-end (Django 1.3) web app providing centralised management of the entire distribution network&lt;/li&gt;&lt;li&gt;custom importer and distributor plugins for Pulp to handle distribution of tree changes within the distribution network&lt;/li&gt;&lt;li&gt;custom importer plugins to handle the import of  trees from their original sources and generation of any additional metadata needed by the internal distribution plugins&lt;/li&gt;&lt;li&gt;generic (and custom, if needed) plugins to make the trees available to the applications that need them&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;I'll be writing more on various details that I consider interesting as I go along. Initially, that will include my plan for the mirroring protocol to be used between the sites, as well as various decisions that need to be made when spinning up a Django project from scratch (while many of my specific answers are shaped by the target environment for internal deployment, the questions I needed to consider should be fairly widely applicable).</description><category>pulpdist</category><category>python</category><guid>https://www.curiousefficiency.org/posts/2011/09/mirror-all-things.html</guid><pubDate>Fri, 09 Sep 2011 02:54:00 GMT</pubDate></item></channel></rss>