<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="CPython, PyPI, and Python's target audience">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Considering Python's Target Audience | Curious Efficiency</title>
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../../rss.xml">
<link rel="canonical" href="https://www.curiousefficiency.org/posts/2017/10/considering-pythons-target-audience/">
<!--[if lt IE 9]><script src="../../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Alyssa Coghlan">
<link rel="prev" href="../../../2016/09/python-packaging-ecosystem/" title="The Python Packaging Ecosystem" type="text/html">
<link rel="next" href="../../../2019/03/what-does-x-equals-a-plus-b-mean/" title='What does "x = a + b" mean?' type="text/html">
<meta property="og:site_name" content="Curious Efficiency">
<meta property="og:title" content="Considering Python's Target Audience">
<meta property="og:url" content="https://www.curiousefficiency.org/posts/2017/10/considering-pythons-target-audience/">
<meta property="og:description" content="CPython, PyPI, and Python's target audience">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-10-09T01:33:41Z">
<meta property="article:tag" content="python">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../../../">

            <span id="blog-title">Curious Efficiency</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.rst" id="sourcelink" class="nav-link">Source</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../../../pages/about/" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="../../../../archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="../../../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../../../rss.xml" class="nav-link">RSS</a>
                </li>
<li class="nav-item">
<a href="https://python-notes.curiousefficiency.org" class="nav-link">Python Notes</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Considering Python's Target Audience</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Alyssa Coghlan
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2017-10-09T01:33:41Z" itemprop="datePublished" title="2017-10-09 01:33">2017-10-09 01:33</time></a>
            </p>
                <p class="commentline">
    
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/2017/10/considering-pythons-target-audience.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.rst" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <nav class="contents" id="who-is-python-being-designed-for" role="doc-toc"><p class="topic-title">Who is Python being designed for?</p>
<ul class="simple">
<li><p><a class="reference internal" href="#use-cases-for-python-s-reference-interpreter" id="toc-entry-1">Use cases for Python's reference interpreter</a></p></li>
<li><p><a class="reference internal" href="#which-audience-does-cpython-primarily-serve" id="toc-entry-2">Which audience does CPython primarily serve?</a></p></li>
<li><p><a class="reference internal" href="#why-is-this-relevant-to-anything" id="toc-entry-3">Why is this relevant to anything?</a></p></li>
<li><p><a class="reference internal" href="#where-does-pypi-fit-into-the-picture" id="toc-entry-4">Where does PyPI fit into the picture?</a></p></li>
<li><p><a class="reference internal" href="#why-are-some-apis-changed-when-adding-them-to-the-standard-library" id="toc-entry-5">Why are some APIs changed when adding them to the standard library?</a></p></li>
<li><p><a class="reference internal" href="#why-are-some-apis-added-in-provisional-form" id="toc-entry-6">Why are some APIs added in provisional form?</a></p></li>
<li><p><a class="reference internal" href="#why-are-only-some-standard-library-apis-upgraded" id="toc-entry-7">Why are only some standard library APIs upgraded?</a></p></li>
<li><p><a class="reference internal" href="#will-any-parts-of-the-standard-library-ever-be-independently-versioned" id="toc-entry-8">Will any parts of the standard library ever be independently versioned?</a></p></li>
<li><p><a class="reference internal" href="#why-do-these-considerations-matter" id="toc-entry-9">Why do these considerations matter?</a></p></li>
</ul></nav><p>Several years ago, I
<a class="reference external" href="../../../2011/04/musings-on-culture-of-python-dev/">highlighted</a>
"CPython moves both too fast and too slowly" as one of the more common causes
of conflict both within the python-dev mailing list, as well as between the
active CPython core developers and folks that decide that participating in
that process wouldn't be an effective use of their personal time and energy.</p>
<p>I still consider that to be the case, but it's also a point I've spent a lot
of time reflecting on in the intervening years, as I wrote that original article
while I was still working for Boeing Defence Australia. The following month,
I left Boeing for Red Hat Asia-Pacific, and started gaining a redistributor
level perspective on
<a class="reference external" href="https://community.redhat.com/blog/2015/02/the-quid-pro-quo-of-open-infrastructure/">open source supply chain management</a>
in large enterprises.</p>
<section id="use-cases-for-python-s-reference-interpreter"><h2><a class="toc-backref" href="#toc-entry-1" role="doc-backlink">Use cases for Python's reference interpreter</a></h2>
<p>While it's a gross oversimplification, I tend to break down CPython's use cases
as follows (note that these categories aren't fully distinct, they're just
aimed at focusing my thinking on different factors influencing the rollout of
new software features and versions):</p>
<ul class="simple">
<li>
<p>Education: educator's main interest is in teaching ways of modelling and
manipulating the world computationally, <em>not</em> writing or maintaining
production software). Examples:</p>
<ul>
<li><p>Australia's <a class="reference external" href="https://aca.edu.au/#home-unpack">Digital Curriculum</a></p></li>
<li><p>Lorena A. Barba's <a class="reference external" href="https://github.com/barbagroup/AeroPython">AeroPython</a></p></li>
</ul>
</li>
<li>
<p>Personal automation &amp; hobby projects: software where the main, and often only,
user is the individual that wrote it. Examples:</p>
<ul>
<li><p>my Digital Blasphemy
<a class="reference external" href="https://nbviewer.jupyter.org/urls/bitbucket.org/ncoghlan/misc/raw/default/notebooks/Digital%20Blasphemy.ipynb">image download notebook</a></p></li>
<li><p>Paul Fenwick's (Inter)National <a class="reference external" href="https://github.com/pjf/rickastley">Rick Astley Hotline</a></p></li>
</ul>
</li>
<li>
<p>Organisational process automation: software where the main, and often only,
user is the organisation it was originally written to benefit. Examples:</p>
<ul>
<li><p>CPython's <a class="reference external" href="https://github.com/python/core-workflow">core workflow tools</a></p></li>
<li><p>Development, build &amp; release management tooling for Linux distros</p></li>
</ul>
</li>
<li>
<p>Set-and-forget infrastructure: software where, for sometimes debatable
reasons, in-life upgrades to the software itself are nigh impossible, but
upgrades to the underlying platform may be feasible. Examples:</p>
<ul>
<li><p>most self-managed corporate and institutional infrastructure (where properly
funded sustaining engineering plans are disturbingly rare)</p></li>
<li><p>grant funded software (where maintenance typically ends when the initial
grant runs out)</p></li>
<li><p>software with strict certification requirements (where recertification is
too expensive for routine updates to be economically viable unless
absolutely essential)</p></li>
<li><p>Embedded software systems without auto-upgrade capabilities</p></li>
</ul>
</li>
<li>
<p>Continuously upgraded infrastructure: software with a robust sustaining
engineering model, where dependency and platform upgrades are considered
routine, and no more concerning than any other code change. Examples:</p>
<ul>
<li><p>Facebook's Python service infrastructure</p></li>
<li><p>Rolling release Linux distributions</p></li>
<li><p>most public PaaS and serverless environments (Heroku, OpenShift, AWS Lambda,
Google Cloud Functions, Azure Cloud Functions, etc)</p></li>
</ul>
</li>
<li>
<p>Intermittently upgraded standard operating environments: environments that do
carry out routine upgrades to their core components, but those upgrades occur
on a cycle measured in years, rather than weeks or months. Examples:</p>
<ul>
<li><p><a class="reference external" href="https://www.vfxplatform.com/">VFX Platform</a></p></li>
<li><p>LTS Linux distributions</p></li>
<li><p>CPython and the Python standard library</p></li>
<li><p>Infrastructure management &amp; orchestration tools (e.g. OpenStack, Ansible)</p></li>
<li><p>Hardware control systems</p></li>
</ul>
</li>
<li>
<p>Ephemeral software: software that tends to be used once and then discarded
or ignored, rather than being subsequently upgraded in place. Examples:</p>
<ul>
<li><p>Ad hoc automation scripts</p></li>
<li><p>Single-player games with a defined "end" (once you've finished them, even
if you forget to uninstall them, you probably won't reinstall them on a new
device)</p></li>
<li><p>Single-player games with little or no persistent state (if you uninstall and
reinstall them, it doesn't change much about your play experience)</p></li>
<li><p>Event-specific applications (the application was tied to a specific physical
event, and once the event is over, that app doesn't matter any more)</p></li>
</ul>
</li>
<li>
<p>Regular use applications: software that tends to be regularly upgraded after
deployment. Examples:</p>
<ul>
<li><p>Business management software</p></li>
<li><p>Personal &amp; professional productivity applications (e.g. Blender)</p></li>
<li><p>Developer tools &amp; services (e.g. Mercurial, Buildbot, Roundup)</p></li>
<li><p>Multi-player games, and other games with significant persistent state, but
no real defined "end"</p></li>
<li><p>Embedded software systems with auto-upgrade capabilities</p></li>
</ul>
</li>
<li>
<p>Shared abstraction layers: software components that are designed to make it
possible to work effectively in a particular problem domain even if you don't
personally grasp all the intricacies of that domain yet. Examples:</p>
<ul>
<li><p>most runtime libraries and frameworks fall into this category (e.g. Django,
Flask, Pyramid, SQL Alchemy, NumPy, SciPy, requests)</p></li>
<li><p>many testing and type inference tools also fit here (e.g. pytest,
Hypothesis, vcrpy, behave, mypy)</p></li>
<li><p>plugins for other applications (e.g. Blender plugins, OpenStack hardware
adapters)</p></li>
<li><p>the standard library itself represents the baseline "world according to
Python" (and that's an
<a class="reference external" href="../../../2015/10/languages-to-improve-your-python.html#broadening-our-horizons">incredibly complex</a>
world view)</p></li>
</ul>
</li>
</ul></section><section id="which-audience-does-cpython-primarily-serve"><h2><a class="toc-backref" href="#toc-entry-2" role="doc-backlink">Which audience does CPython primarily serve?</a></h2>
<p>Ultimately, the main audiences that CPython and the standard library specifically
serve are those that, for whatever reason, aren't adequately served by the
combination of a more limited standard library and the installation of
explicitly declared third party dependencies from PyPI.</p>
<p>To oversimplify the above review of different usage and deployment models even
further, it's possible to summarise the single largest split in Python's user
base as the one between those that are using Python as a <em>scripting language</em>
for some environment of interest, and those that are using it as an <em>application
development language</em>, where the eventual artifact that will be distributed is
something other than the script that they're working on.</p>
<p>Typical developer behaviours when using Python as a scripting language include:</p>
<ul class="simple">
<li><p>the main working unit consists of a single Python file (or Jupyter notebook!),
rather than a directory of Python and metadata files</p></li>
<li><p>there's no separate build step of any kind - the script is distributed <em>as</em> a
script, similar to the way standalone shell scripts are distributed</p></li>
<li><p>there's no separate install step (other than downloading the file to an
appropriate location), as it is expected that the required runtime environment
will be preconfigured on the destination system</p></li>
<li><p>no explicit dependencies stated, except perhaps a minimum Python version,
or else a statement of the expected execution environment. If dependencies
outside the standard library are needed, they're expected to be provided by
the environment being scripted (whether that's an operating system,
a data analysis platform, or an application that embeds a Python runtime)</p></li>
<li><p>no separate test suite, with the main test of correctness being "Did the
script do what you wanted it to do with the input that you gave it?"</p></li>
<li><p>if testing prior to live execution is needed, it will be in the form of a
"dry run" or "preview" mode that conveys to the user what the software <em>would</em>
do if run that way</p></li>
<li><p>if static code analysis tools are used at all, it's via integration into the
user's software development environment, rather than being set up separately
for each individual script</p></li>
</ul>
<p>By contrast, typical developer behaviours when using Python as an application
development language include:</p>
<ul class="simple">
<li><p>the main working unit consists of a directory of Python and metadata files,
rather than a single Python file</p></li>
<li><p>these is a separate build step to prepare the application for publication,
even if it's just bundling the files together into a Python sdist, wheel
or zipapp archive</p></li>
<li><p>whether there's a separate install step to prepare the application for use
will depend on how the application is packaged, and what the supported target
environments are</p></li>
<li><p>external dependencies are expressed in a metadata file, either directly in
the project directory (e.g. <code class="docutils literal">pyproject.toml</code>, <code class="docutils literal">requirements.txt</code>,
<code class="docutils literal">Pipfile</code>), or as part of the generated publication archive (e.g.
<code class="docutils literal">setup.py</code>, <code class="docutils literal">flit.ini</code>)</p></li>
<li><p>a separate test suite exists, either as unit tests for the Python API,
integration tests for the functional interfaces, or a combination of the two</p></li>
<li><p>usage of static analysis tools is configured at the project level as part of
its testing regime, rather than being dependent on</p></li>
</ul>
<p>As a result of that split, the main purpose that CPython and the standard
library end up serving is to define the redistributor independent baseline
of assumed functionality for educational and ad hoc Python scripting
environments 3-5 years after the corresponding CPython feature release.</p>
<p>For ad hoc scripting use cases, that 3-5 year latency stems from a combination
of delays in redistributors making new releases available to their users, and
users of those redistributed versions taking time to revise their standard
operating environments.</p>
<p>In the case of educational environments, educators need that kind of time to
review the new features and decide whether or not to incorporate them into the
courses they offer their students.</p>
</section><section id="why-is-this-relevant-to-anything"><h2><a class="toc-backref" href="#toc-entry-3" role="doc-backlink">Why is this relevant to anything?</a></h2>
<p>This post was largely inspired by the Twitter discussion following on from
<a class="reference external" href="https://twitter.com/ncoghlan_dev/status/916994106819088384">this comment of mine</a>
citing the Provisional API status defined in
<a class="reference external" href="https://www.python.org/dev/peps/pep-0411/">PEP 411</a> as an example of an
open source project issuing a de facto invitation to users to participate more
actively in the design &amp; development process as co-creators, rather than only
passively consuming already final designs.</p>
<p>The responses included several expressions of frustration regarding the difficulty
of supporting provisional APIs in higher level libraries, without those libraries
making the provisional status transitive, and hence limiting support for any
related features to only the latest version of the provisional API, and not any
of the earlier iterations.</p>
<p>My <a class="reference external" href="https://twitter.com/ncoghlan_dev/status/917092464355241984">main reaction</a>
was to suggest that open source publishers should impose whatever support
limitations they need to impose to make their ongoing maintenance efforts
personally sustainable. That means that if supporting older iterations of
provisional APIs is a pain, then they should only be supported if the project
developers themselves need that, or if somebody is paying them for the
inconvenience. This is similar to my view on whether or not volunteer-driven
projects should support older commercial LTS Python releases for free when it's
a hassle for them to do: I <a class="reference external" href="../../../2015/04/stop-supporting-python26/">don't think they should</a>,
as I expect most such demands to be stemming from poorly managed institutional
inertia, rather than from genuine need (and if the need <em>is</em> genuine, then it
should instead be possible to find some means of paying to have it addressed).</p>
<p>However, my <a class="reference external" href="https://twitter.com/ncoghlan_dev/status/917088410162012160">second reaction</a>,
was to realise that even though I've touched on this topic over the years (e.g.
in the original 2011 article linked above, as well as in Python 3 Q &amp; A answers
<a class="reference external" href="https://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#wouldn-t-a-python-2-8-release-help-ease-the-transition">here</a>,
<a class="reference external" href="https://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#doesn-t-this-make-python-look-like-an-immature-and-unstable-platform">here</a>,
and <a class="reference external" href="https://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#what-about-insert-other-shiny-new-feature-here">here</a>,
and to a lesser degree in last year's article on the
<a class="reference external" href="../../../2016/09/python-packaging-ecosystem/">Python Packaging Ecosystem</a>),
I've never really attempted to directly explain the impact it has on the standard
library design process.</p>
<p>And without that background, some aspects of the design process, such as the
introduction of provisional APIs, or the introduction of
inspired-by-but-not-the-same-as, seem completely nonsensical, as they appear to be an attempt to standardise
APIs without actually standardising them.</p>
</section><section id="where-does-pypi-fit-into-the-picture"><h2><a class="toc-backref" href="#toc-entry-4" role="doc-backlink">Where does PyPI fit into the picture?</a></h2>
<p>The first hurdle that <em>any</em> proposal sent to python-ideas or python-dev has to
clear is answering the question "Why isn't a module on PyPI good enough?". The
vast majority of proposals fail at this step, but there are several common
themes for getting past it:</p>
<ul class="simple">
<li><p>rather than downloading a suitable third party library, novices may be prone
to copying &amp; pasting bad advice from the internet at large (e.g. this is why
the <code class="docutils literal">secrets</code> library now exists: to make it less likely people will use the
<code class="docutils literal">random</code> module, which is intended for games and statistical simulations,
for security-sensitive purposes)</p></li>
<li><p>the module is intended to provide a reference implementation and to enable
interoperability between otherwise competing implementations, rather than
necessarily being all things to all people (e.g. <code class="docutils literal">asyncio</code>, <code class="docutils literal">wsgiref</code>,
<code class="docutils literal">unittest`</code>, and <code class="docutils literal">logging</code> all fall into this category)</p></li>
<li><p>the module is intended for use in other parts of the standard library (e.g.
<code class="docutils literal">enum</code> falls into this category, as does <code class="docutils literal">unittest</code>)</p></li>
<li><p>the module is designed to support a syntactic addition to the language (e.g.
the <code class="docutils literal">contextlib</code>, <code class="docutils literal">asyncio</code> and <code class="docutils literal">typing</code> modules fall into this
category)</p></li>
<li><p>the module is just plain useful for ad hoc scripting purposes (e.g.
<code class="docutils literal">pathlib</code>, and <code class="docutils literal">ipaddress</code> fall into this category)</p></li>
<li><p>the module is useful in an educational context (e.g. the <code class="docutils literal">statistics</code>
module allows for interactive exploration of statistic concepts, even if you
wouldn't necessarily want to use it for full-fledged statistical analysis)</p></li>
</ul>
<p>Passing this initial "Is PyPI obviously good enough?" check isn't enough to
ensure that a module will be accepted for inclusion into the standard library,
but it's enough to shift the question to become "Would including the proposed
library result in a net improvement to the typical introductory Python software
developer experience over the next few years?"</p>
<p>The introduction of <code class="docutils literal">ensurepip</code> and <code class="docutils literal">venv</code> modules into the standard library
also makes it clear to redistributors that we expect Python level packaging
and installation tools to be supported in addition to any platform specific
distribution mechanisms.</p>
</section><section id="why-are-some-apis-changed-when-adding-them-to-the-standard-library"><h2><a class="toc-backref" href="#toc-entry-5" role="doc-backlink">Why are some APIs changed when adding them to the standard library?</a></h2>
<p>While existing third party modules are sometimes adopted wholesale into the
standard library, in other cases, what actually gets added is a redesigned
and reimplemented API that draws on the user experience of the existing API,
but drops or revises some details based on the additional design considerations
and privileges that go with being part of the language's reference
implementation.</p>
<p>For example, unlike its popular third party predecessor, <code class="docutils literal">path.py`, ``pathlib</code>
does <em>not</em> define string subclasses, but instead independent types. Solving
the resulting interoperability challenges led to the definition of the
filesystem path protocol, allowing a wider range of objects to be used with
interfaces that work with filesystem paths.</p>
<p>The API design for the <code class="docutils literal">ipaddress</code> module was adjusted to explicitly
separate host interface definitions (IP addresses associated with particular
IP networks) from the definitions of addresses and networks in order to serve
as a better tool for teaching IP addressing concepts, whereas the original
<code class="docutils literal">ipaddr</code> module is less strict in the way it uses networking terminology.</p>
<p>In other cases, standard library modules are constructed as a synthesis of
multiple existing approaches, and may also rely on syntactic features that
didn't exist when the APIs for pre-existing libraries were defined. Both of
these considerations apply for the <code class="docutils literal">asyncio</code> and <code class="docutils literal">typing</code> modules,
while the latter consideration applies for the <code class="docutils literal">dataclasses</code> API being
considered in PEP 557 (which can be summarised as "like attrs, but using
variable annotations for field declarations").</p>
<p>The working theory for these kinds of changes is that the existing libraries
aren't going away, and their maintainers often aren't all that interested
in putitng up with the constraints associated with standard library maintenance
(in particular, the relatively slow release cadence). In such cases, it's
fairly common for the documentation of the standard library version to feature
a "See Also" link pointing to the original module, especially if the third
party version offers additional features and flexibility that were omitted
from the standard library module.</p>
</section><section id="why-are-some-apis-added-in-provisional-form"><h2><a class="toc-backref" href="#toc-entry-6" role="doc-backlink">Why are some APIs added in provisional form?</a></h2>
<p>While CPython does maintain an API deprecation policy, we generally prefer not
to use it without a compelling justification (this is especially the case
while other projects are attempting to maintain compatibility with Python 2.7).</p>
<p>However, when adding new APIs that are inspired by existing third party ones
without being exact copies of them, there's a higher than usual risk that some
of the design decisions may turn out to be problematic in practice.</p>
<p>When we consider the risk of such changes to be higher than usual, we'll mark
the related APIs as provisional, indicating that conservative end users may
want to avoid relying on them at all, and that developers of shared abstraction
layers may want to consider imposing stricter than usual constraints on which
versions of the provisional API they're prepared to support.</p>
</section><section id="why-are-only-some-standard-library-apis-upgraded"><h2><a class="toc-backref" href="#toc-entry-7" role="doc-backlink">Why are only some standard library APIs upgraded?</a></h2>
<p>The short answer here is that the main APIs that get upgraded are those where:</p>
<ul class="simple">
<li><p>there isn't likely to be a lot of external churn driving additional updates</p></li>
<li><p>there are clear benefits for either ad hoc scripting use cases or else in
encouraging future interoperability between multiple third party solutions</p></li>
<li><p>a credible proposal is submitted by folks interested in doing the work</p></li>
</ul>
<p>If the limitations of an existing module are mainly noticeable when using the
module for application development purposes (e.g. <code class="docutils literal">datetime</code>), if
redistributors already tend to make an improved alternative third party option
readily available (e.g. <code class="docutils literal">requests</code>), or if there's a genuine conflict between
the release cadence of the standard library and the needs of the package in
question (e.g. <code class="docutils literal">certifi</code>), then the incentives to propose a change to the
standard library version tend to be significantly reduced.</p>
<p>This is essentially the inverse to the question about PyPI above: since PyPI
usually <em>is</em> a sufficiently good distribution mechanism for application
developer experience enhancements, it makes sense for such enhancements to be
distributed that way, allowing redistributors and platform providers to make
their own decisions about what they want to include as part of their default
offering.</p>
<p>Changing CPython and the standard library only comes into play when there is
perceived value in changing the capabilities that can be assumed to be present
by default in 3-5 years time.</p>
</section><section id="will-any-parts-of-the-standard-library-ever-be-independently-versioned"><h2><a class="toc-backref" href="#toc-entry-8" role="doc-backlink">Will any parts of the standard library ever be independently versioned?</a></h2>
<p>Yes, it's likely the bundling model used for <code class="docutils literal">ensurepip</code> (where CPython
releases bundle a recent version of <code class="docutils literal">pip</code> without actually making it part
of the standard library) may be applied to other modules in the future.</p>
<p>The most probable first candidate for that treatment would be the <code class="docutils literal">distutils</code>
build system, as switching to such a model would allow the build system to be
more readily kept consistent across multiple releases.</p>
<p>Other potential candidates for this kind of treatment would be the Tcl/Tk
graphics bindings, and the IDLE editor, which are already unbundled and turned
into an optional addon installations by a number of redistributors.</p>
</section><section id="why-do-these-considerations-matter"><h2><a class="toc-backref" href="#toc-entry-9" role="doc-backlink">Why do these considerations matter?</a></h2>
<p>By the very nature of things, the folks that tend to be most actively involved
in open source development are those folks working on open source applications
and shared abstraction layers.</p>
<p>The folks writing ad hoc scripts or designing educational exercises for their
students often won't even think of themselves as software developers - they're
teachers, system administrators, data analysts, quants, epidemiologists,
physicists, biologists, business analysts, market researchers, animators,
graphical designers, etc.</p>
<p>When all we have to worry about for a language is the application developer
experience, then we can make a lot of simplifying assumptions around what
people know, the kinds of tools they're using, the kinds of development
processes they're following, and the ways they're going to be building and
deploying their software.</p>
<p>Things get significantly more complicated when an application runtime <em>also</em>
enjoys broad popularity as a scripting engine. Doing either job well is
already difficult, and balancing the needs of both audiences as part of a single
project leads to frequent incomprehension and disbelief on both sides.</p>
<p>This post isn't intended to claim that we never make incorrect decisions as part
of the CPython development process - it's merely pointing out that the most
reasonable reaction to seemingly nonsensical feature additions to the Python
standard library is going to be "I'm not part of the intended target audience
for that addition" rather than "I have no interest in that, so it must be a
useless and pointless addition of no value to anyone, added purely to annoy me".</p>
</section>
</div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../../../2016/09/python-packaging-ecosystem/" rel="prev" title="The Python Packaging Ecosystem">Previous post</a>
            </li>
            <li class="next">
                <a href="../../../2019/03/what-does-x-equals-a-plus-b-mean/" rel="next" title='What does "x = a + b" mean?'>Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="boredomandlaziness",
            disqus_url="https://www.curiousefficiency.org/posts/2017/10/considering-pythons-target-audience/",
        disqus_title="Considering Python's Target Audience",
        disqus_identifier="cache/posts/2017/10/considering-pythons-target-audience.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="boredomandlaziness";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2024 <a href="mailto:ncoghlan@gmail.com">Alyssa Coghlan</a> - <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, republish as you wish. - Powered by <a href="https://getnikola.com/">Nikola</a>
            
            
        </footer>
</div>
</div>


        <script src="../../../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
