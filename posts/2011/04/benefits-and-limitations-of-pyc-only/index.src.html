<html><body><a href="http://programmers.stackexchange.com/questions/66616/ways-to-prevent-client-seeing-my-code">This Stack Overflow question</a> hit my feed reader recently, prompting the usual discussion about the effectiveness of PYC only distribution as a mechanism for obfuscating Python code.<br><br><h3>PYC Only Distribution</h3>In case it isn't completely obvious from the name, PYC only distribution is a matter of taking your code base, running "compileall" (or an equivalent utility) over it to generate the .pyc files, and then removing all of the original .py source files from the distributed version.<br><br>Plenty of Python programmers (especially the pure open source ones) consider this practice an absolute travesty and would be quite happy to see it disallowed entirely. Early drafts of PEP 3147 (PYC Repository Directories) in fact proposed exactly that - in the absence of the associated source file, a compiled PYC file would have been ignored.<br><br>However, such blatant backwards incompatibility aroused protests from several parties (including me), and support for PYC-only distribution was restored in later versions of the PEP (although "compileall" now requires a command line switch in order to generate the files in the correct location for PYC-only distribution).<br><br><h3>Use Cases</h3>As I see it, there are a couple of legitimate use cases for PYC-only distribution:<br><ul><li>Embedded firmware: If your code is going onto an embedded system where space is at a premium, there's no point including both your source code <i>and</i> the PYC files. Better to just include the compiled ones, as that is all you really need</li><li>Cutting down on support calls (or at least making the ones you do get more comprehensible): Engineers and scientists like to tinker. It's in their nature. When they know just enough Python to be a danger to themselves and others, you can get some truly bizarre tickets if they've been fiddling with things and failed to revert their changes correctly (or didn't revert them at all). Shipping only the PYC files can help make sure the temptation to fiddle never even arises</li></ul><br>Of the two, the former is by far the stronger use case. The latter is attempting a technical solution to a social problem and those rarely work out well in the long run. Still, however arguable its merits, I personally consider deterrence of casual modifications a valid use case for the feature.<br><br><h3>Drawbacks</h3>Stripping the source code out of the distribution does involve some pretty serious drawbacks. The main one is the fact that you no longer have the ability to fall back to re-compilation if the embedded magic cookie doesn't match the execution environment.<br><br>This restricts practical PYC-only distribution to comparatively constrained environments that can ensure a matching version of Python is available to execute the PYC files, such as:<br><ul><li>Embedded systems</li><li>Corporate SOEs (Standard Operating Environments)</li><li>Bundled interpreters targeting a specific platform</li></ul><br>Cross-platform compatibility of PYC files (especially for 32-bit vs 64-bit and ARM vs x86) is also significantly less robust than the cross-platform compatibility of Python source code.<br><br><h3>Limitations</h3>Going back to the SO question that most recently got me thinking about this topic, the big limitation to keep in mind is this: <i>shipping only PYC files will not reliably keep anyone from reading your code</i>. While comments do get thrown away by the compilation process, and docstrings can be stripped with the "-OO" option, Python will always know the <i>names</i> of all the variables at runtime, so that information will always be present in the compiled bytecode. Given both the code structure and the original variable names, most decent programmers are going to be able to understand what the code was doing, even if they don't have access to the comments and docstrings.<br><br>While there aren't any currently active open source projects that provide full decompilation of CPython bytecode, such projects have existed in the past and could easily exist again in the future. There are also companies which provide Python decompilation as a paid service (decompyle and depython are the two that I am personally aware of).<br><br><h3>Alternatives</h3>You can deter casual tinkering reasonably well by placing your code in a zip archive with a non-standard extension (even .py!). If you prepend an appropriate shebang line, you can even mark it as executable on POSIX based systems (see <a href="/2011/03/what-is-python-script.html">this post</a> for more information).<br><br>You could also write your code in Cython or RPython instead of vanilla Python and ship fully compiled executable binaries.<br><br>There are minifier projects for Python (such as <a href="http://pypi.python.org/pypi/mnfy">mnfy</a>) that could be fairly readily adapted to perform obfuscation tricks (such as replacing meaningful variable names with uninformative terms like "_id1").</body></html>
