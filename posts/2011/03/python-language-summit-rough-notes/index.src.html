<html><body><p>Same drill, different day, more people, more notes :)<br><br>Still just my interpetation, though. Will probably highlight a few things I find particularly interesting again tomorrow (as I did for the VM summit).<br><br>PSF Communications (Doug Hellman)<br>- currently writing about PSF funding and similar activities<br>- would like to include more technical material summarising python-dev discussions<br>- how best to go about that<br>- new blog, not existing PSF blog<br>- existing PSF board not in the position to do it<br>- Guido: core devs already do a lot via PEPs and mailing list, likely not keen to write blog as well<br>- may be better to get others to do it, willing to follow discussions of interest<br>- posts may be primarily pointers to other resources (e.g. PEPs, mailing list posts)<br>- all implementations<br>- major new releases should go on python.org as NEWS items<br><br>Warnings for things that may cause problems on different implementations<br>- ResourceWarning helps to pick up reliance on CPython specific refcounting<br>- CompatibilityWarning for reliance on non-strings in namespaces (e.g. classes)<br>- update Language Spec to clarify ambiguous situations<br>- like ResourceWarning, silence CompatibilityWarning by default<br>- what to do about builtin functions that currently aren't descriptors (i.e. doesn't change behaviour when retrieved from a class)<br>- e.g. make staticmethod objects directly callable<br>- big gray area in language spec - callables may not be descriptors<br>- perhaps change CPython builtin descriptors to warn about this situation<br>- another use case for CompatibilityWarning<br>- Guido not convinced the builtin function problem can be handled in general<br>- a better callable variant of staticmethod may be better, that allows the default descriptor behaviour to be easily stripped from any function<br>- doesn't want to require that all builtin functions follow descriptor protocol, since it is already the case that many callables don't behave like methods<br>- a better staticmethod would allow the descriptor protocol to be stripped, ensuring such functions can be safely stored in classes without changing behaviour<br><br>Standard Library separation<br>- see VM summit notes<br>- over time, migrate over to separate repository for standard lib, update <br>- need Python and C modules stay in sync<br>- buildbots for standard library<br>- challenge of maintaining compatibility as standard lib adopts new language changes<br>- need a PEP to provide guarantees that C accelerators are kept in sync (Brett Cannon volunteered to write test)<br>- bringing back pure Python alternatives to C standard library is encouraged, but both need to be tested<br>- accelerator modules should be subsets of the Python API  <br>- Brett will resurrect standard library PEP once importlib is done<br>- full consolidation unlikely to be possible for 2.7 (due to CPython maintenance freeze)<br><br>Speed Benchmarking<br>- see VM summit notes<br>- really good for tracking performance changes across versions<br>- common set of benchmarks<br>- OSU OSL are willing to host it<br>- backend currently only compares two versions<br>- first step is to get up and running with Linux comparisons first, look at other OS comparisons later<br>- hypervisors mess with performance benchmarks, hence need real machines<br>- should set up some infrastructure on python.org (benchmark SIG mailing list, hg repository)<br>- eventually, redirect speed.pypy.org to new speed.python.org<br>- longer term, may add new benchmarks<br><br>Exception data<br>- need to eliminate need to parse error strings to get info from exceptions<br>- should be careful that checks of message content aren't overly restrictive<br>- PEP 3151 to improve IO error handling? (Guido still has some reservations)<br>- ImporError needs to name module<br>- KeyError, IndexError, ValueError?<br>- need to be careful when it comes to creating reference loops<br>- exception creation API also an issue, since structured data needs to be provided<br><br>Contributor Licensing Agreements<br>- Jesse and Van looking to get electronic CLAs set up<br>- will ensure adequately covers non-US jurisdictions<br><br>Google Summer of Code<br>- encouraging proposals under the PSF umbrella<br><br>Packaging<br>- distutils2 should land in 3.3 during the sprints<br>- namespace packages (PEP 382) will land in 3.3<br>- external name for backports should be different from internal name<br>- too late to introduce a standard top level parent for stdlib packages<br>- external backports for use in older versions is OK<br>- external maintenance is bad<br>- hence fast development cycles incompatible with stdlib<br>- want to give distutils2 a new name in stdlib for 3.3, so future backports based on version in 3.4 won't conflict with the standard version in 3.3<br><br>Python 3 adoption<br>- py3ksupport.appspot.com (Brett Cannon)<br>- supplements inadequate trope data on PyPI with manual additions<br>- Georg Brandl has graphical tracker of classification data on PyPI over time<br>- Allison Randall/Barry Warsaw have been doing similar dependency tracking and migration info for Ubuntu<br>- giant wiki page for Fedora Python app packaging<br>- good dependency info would provide a good ranking system for effectively targeting grants<br>- 3.python.org? getpython3.com? need to choose an official URL<br>- funding may help with PyPy migration<br>- IronPython will be looking at 3.x support once 2.7 is available (this week/next week timeframe)<br>- Jython focused on 2.6 now, may go direct to 3.x after that (haven't decided yet)<br>- PSF funding needs a specific proposal with specific developer resources with the necessary expertise and available time<br>- CObject-&gt;Capsule change is a compatibility issue for C extension modules<br>- Django targeting Python 3 support by the end of summer<br>- zc.buildout is a dependency of note that hasn't been ported yet (Pycon sprint topic)<br>- other migration projects being tackled at Pycon sprints (webop?)<br><br>Python upstream and distro packaging<br>- PEP 394 - recommendations for symlinks practices<br>- PEP 3147 and 3149 were heavily targeted at helping distros share directories across versions<br>- namespace packages (PEP 382)<br>- PEP 384 stable ABI (done for 3.2)<br>- better tools needed to help with migration to stable ABI<br><br>Baseline Python distro installs<br>- system python varies in terms of what is installed<br>- challenging to target, as available modules vary<br>- "build from source" is only a partial answer as some build dependencies are optional<br>- distros make some changes to support differences in directory layouts<br>- some changes affect Python app dependencies (e.g. leaving out distutils)<br>- conflict between "system Python" use case of what is needed to run distro utilities and "arbitrary app target" for running third party apps<br>- distributing separate Python under app control is not ideal, due to security patch management issues<br>- specific problems are caused by removal of stuff from base install (e.g. distutils)<br>- other problem is when distro uses old versions of packages (but virtualenv can help with that)<br>- may help if a "python-minimal" was used for the essential core, with "python" installing all the extras (including distutils, tkinter, etc)<br>- then have a further python-extras (or equivalent) that adds everything else the distro needs for its own purposes<br>- distros tend to work by taking a CPython build and then splitting it up into various distro packages<br>- to handle additions, would be good to be able to skip site-packages inclusion in sys.path (ala virtualenv).<br>- "-S" turns off too much (skips site.py entirely, not just adding site-packages to sys.path)<br>- "-s" only turns off user site-packages, not system site-packages<br><br>Python 3.3 proposed changes to strings to reduce typical memory usage<br>- PEP 393 changes to internal string representation (implementation as GSoC project)<br>- Unicode memory layout currently split in order to more easily support resizing and subclassing in C<br>- need to build and measure to see speed and memory impacts<br>- alternative idea may be to explore multiple implementation techniques (similar to PyPy)<br><br>Speed (again!)<br>- Unladen Swallow dormant. Major maintainers moved on to other things, fair bit of work in picking it up<br>- even trying to glean piecemeal upgrades (e.g. to cPickle) is a challenge<br>- interest in speeding up Python has really shifted to PyPy<br>- for CPython, gains would need to be really substantial to justify additional complexity<br>- really need to get the macro benchmarks available on 3.x<br>- Guido: pickle speedup experience is to be cautious, even when the speed gains are large. <br>- speed hack attempts on CPython are still of interest, especially educational ones<br>- speeding up overall is a very hard problem, but fixing specific bottlenecks is good<br>- stable ABI will help<br>- PyPy far more sensitive to refcounting bugs than CPython<br>- static analysis to pick up refcounting bugs could help a great deal<br>- "Here there be dragons": Unladen Swallow shows that overall speedups are not easy to come by<br><br>Regex engine upgrade<br>- new regex library proposed<br>- added many new features, including the Unicode categories needed to select out Python 3.x identifiers<br>- potentially big hassle for other implementations since re module includes a lot of C<br>- IronPython currently translates to .NET compatible regexes, but could rewrite more custom code<br><br>GUI Library<br>- Guido: GUI libraries are nearly as complicated as the rest of Python put together and just aren't a good fit with the release cycle of the standard lib<br>- Don't want to add another one, but don't want to remove Tcl/Tk support either<br><br>twisted.reactor/deferred style APIs in the standard library<br>- asyncore/aynchat still has users<br>- would like to have an alternative in the stdlib that offers a better migration path to Twisted<br>- deferred could be added, such that asyncore based apps can benefit from it<br>- reactor model separates transport/protocol concerns far more cleanly than asyncore<br>- protocol level API and transport level API for asyncore may be a better option<br>- would allow asyncore based applications to more easily migrate to other async loops<br>- defining in a PEP would allow this to be the "WSGI" for async frameworks ("asyncref", anyone?) (Jesse suggested concurrent.eventloop instead)<br>- still need someone to step up to write the PEP and integrate the feedback from the Twisted team and the other async frameworks<br>- plenty of async programming folks able to help and provide feedback (including glyph)<br>- having this standardised would help make event loop based programming more pluggable<br>- Guido still doesn't like the "deferred" name<br>- Glyph considers deferred to be less important than standardising the basic event loop interface</p></body></html>